module Cyclics

import Data.Fin
import Foundations.Cardinality
import Foundations.Functions
import Algebra.Groups
import Algebra.Homomorphisms
import NumberTheory.DivisionAlgorithm

%default total
%access public export

||| Conversion always sends Z to FZ
natToFinZFZ : nat_to_fin Z m lte_prf = FZ
natToFinZFZ {m = Z} {lte_prf = lte_prf} = Refl
natToFinZFZ {m = (S k)} {lte_prf = lte_prf} = Refl

||| Group in which every element is the power of a generator
interface Group a => CyclicGroup a where
  gen : a
  isCyclic : (el : a) ->
             (order : Nat ** (gen <^> order = el))

||| Quicker way of accessing an element's order
getOrd : CyclicGroup a => a -> Nat
getOrd x = fst $ isCyclic x

||| Predicate that a group element raised to a minimal integer is the identity
data Order : Group a =>
             (el : a) ->
             (order : Nat) ->
             Type where
  HasOrder : Group a =>
             (el : a) ->
             (order : Nat) ->
             el <^> order = Groups.zero ->
             ((order' : Nat) ->
              el <^> order' = Groups.zero ->
              LTE order order') ->
             Order el order

||| Group generated by the identity has order 1
trivialGroup : CyclicGroup a =>
               (Cyclics.gen = Groups.zero {a}) ->
               a ~= 1
trivialGroup {a} eqg = Finite _ _ ((\_ => FZ) ** Bij _ inj srj) where
  inj x y _ with (isCyclic x, isCyclic y)
    | ((x_ord ** x_eq), (y_ord ** y_eq)) = trans (sym x_zero) y_zero where
      x_zero : Groups.zero = x
      x_zero = rewrite sym (powerOfZero {a} x_ord) in rewrite sym eqg in x_eq
      y_zero : Groups.zero = y
      y_zero = rewrite sym (powerOfZero {a} y_ord) in rewrite sym eqg in y_eq
  srj FZ = (gen ** Refl)
  srj (FS x) = absurd $ FinZAbsurd x
