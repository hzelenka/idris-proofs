module Cyclics

import Data.Fin
import Foundations.Sets
import Foundations.Functions
import Algebra.Groups

%default total
%access public export

interface Group a => CyclicGroup a where
  gen : a
  is_cyclic : (el : a) ->
              (order : Nat ** (gen <^> order = el))

data Order : Group a =>
             (el : a) ->
             (order : Nat) ->
             Type where
  HasOrder : Group a =>
             (el : a) ->
             (order : Nat) ->
             el <^> order = Groups.zero ->
             ((order' : Nat) ->
              el <^> order' = Groups.zero ->
              LTE order order') ->
             Order el order

infixl 2 //
data (//) : Nat ->
            Nat ->
            Type where
  Divides : (m : Nat) ->
            (n : Nat) ->
            (k : Nat) ->
            m * k = n ->
            m // n

-- Group generated by the identity has order 1
trivial_group : CyclicGroup a =>
                (Cyclics.gen = Groups.zero {a}) ->
                a ~= 1
trivial_group {a} eqg = Equi a 1 ((\_ => FZ) **
                        Bij _ (Inj _ inj) (Srj _ srj)) where
  inj x y _ with (is_cyclic x, is_cyclic y)
    | ((x_ord ** x_eq), (y_ord ** y_eq)) = trans (sym x_zero) y_zero where
      x_zero : Groups.zero = x
      x_zero = rewrite sym (power_of_zero {a} x_ord) in rewrite sym eqg in x_eq
      y_zero : Groups.zero = y
      y_zero = rewrite sym (power_of_zero {a} y_ord) in rewrite sym eqg in y_eq
  srj FZ = (gen ** Refl)
  srj (FS x) = absurd $ FinZAbsurd x

-- Order of a cyclic group is that of the generator
gen_ord_grp_ord : CyclicGroup a =>
                  (n : Nat) ->
                  Order {a} Cyclics.gen n ->
                  a ~= n

-- Order of the generator is that of the group
grp_ord_gen_ord : CyclicGroup a =>
                  (n : Nat) ->
                  a ~= n ->
                  Order {a} Cyclics.gen n
