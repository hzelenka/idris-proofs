module Cyclics

import Data.Fin
import Foundations.Cardinality
import Foundations.Functions
import Algebra.Groups
import Algebra.Homomorphisms
import NumberTheory.DivisionAlgorithm

%default total
%access public export

-- Conversion always sends Z to FZ
nat_to_fin_z_fz : nat_to_fin Z m lte_prf = FZ
nat_to_fin_z_fz {m = Z} {lte_prf = lte_prf} = Refl
nat_to_fin_z_fz {m = (S k)} {lte_prf = lte_prf} = Refl

interface Group a => CyclicGroup a where
  gen : a
  is_cyclic : (el : a) ->
              (order : Nat ** (gen <^> order = el))

get_ord : CyclicGroup a => a -> Nat
get_ord x = fst $ is_cyclic x

data Order : Group a =>
             (el : a) ->
             (order : Nat) ->
             Type where
  HasOrder : Group a =>
             (el : a) ->
             (order : Nat) ->
             el <^> order = Groups.zero ->
             ((order' : Nat) ->
              el <^> order' = Groups.zero ->
              LTE order order') ->
             Order el order

-- Group generated by the identity has order 1
trivial_group : CyclicGroup a =>
                (Cyclics.gen = Groups.zero {a}) ->
                a ~= 1
trivial_group {a} eqg = Finite _ _ ((\_ => FZ) ** Bij _ inj srj) where
  inj x y _ with (is_cyclic x, is_cyclic y)
    | ((x_ord ** x_eq), (y_ord ** y_eq)) = trans (sym x_zero) y_zero where
      x_zero : Groups.zero = x
      x_zero = rewrite sym (power_of_zero {a} x_ord) in rewrite sym eqg in x_eq
      y_zero : Groups.zero = y
      y_zero = rewrite sym (power_of_zero {a} y_ord) in rewrite sym eqg in y_eq
  srj FZ = (gen ** Refl)
  srj (FS x) = absurd $ FinZAbsurd x
